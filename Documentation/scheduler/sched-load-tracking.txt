			  Load Tracking
			  -------------

CONTENTS
========

 1. Overview
 2. Load Tracking Definitions
 3. Load Tracking with PELT
 4. Load Tracking Example


1. Overview
===========

- Definitions of things we use in load tracking
- Example showing the difference between using runnable time or running
  time for Per-Entity Load Tracking (PELT).
- XXX


2. Load Tracking Definitions
============================

- Cpu:

  A cpu denotes to the smallest compute resource, referring to a hardware
  thread on an SMT system, otherwise it refers to a processor core.

  XXX The fact that subsets of cpus in an multiprocessor environment share
  execution resources will be neglected. (SMT) XXX

- Running/runnable/blocked:

  These terms refer to task states. A running task is the currently
  executing task, a runnable task can run once the currently executing
  task has relinquished the cpu and a blocked task is currently waiting
  on the availability of an event or a resource. The term 'runnable' stands
  for all tasks which are currently on the run queue but also includes the
  running task.

- Cpu utilization:

  The amount of time a cpu is busy executing instructions over an elapsed
  period of time. It is the quotient '(busy time)/period' and therefore a
  value between 0 and 1.

  To describe the busy time, the run time of the currently 'runnable'
  tasks or the run time of the currently 'running' task could be used.

- Cpu load:

  A metric for task placement and load balance decisions which depends on
  the used cpu load metrix and the work performed by this cpu, i.e. wether
  the workload is cpu bound or memory bound.
  We neglect the effect of memory bound workloads for now and assume that
  a workload is only limited by the Cpu capacity.

  One possible cpu load metrix is cpu utilization.

- Cpu capacity:

  The relative ability of a cpu to perform work(load). It is a metric to
  describe how many cpu load a cpu is able to hold.

- Weight:

  The weight of a task (sched entity) depends on the task priority
  (niceness) and the scheduling policy. A task with a nice value of
  0 has a weight of 1024.

- Latency:

  trade-off between latency and cpu utilization
  XXX -> check rt literature
  Latency is not considered here any futher.

3. Load Tracking with PELT
==========================

for tasks:

- cpu load (based on 'runnable' and weighted (with task priority):

contrib_runnable(t) = weight(t) * runnable_avg_sum(t)/(runnable_avg_period(t) + 1)

cpu load = \sum_{t=t_1}^{t_n} contrib_runnable(t) /* we don't use blocked load at
                                                     the moment */

- cpu load (based on 'running' and un-weighted)

contrib_running(t) = running_avg_sum(t)/(running_avg_period(t) + 1)

cpu load = \sum_{t=t_1}^{t_n} contrib_running(t)


4. Load Tracking Example
=============================

gnuplot snippet to paste into gnuplot shell:

# Example to illustrate the Per-Entity Load Tracking (PELT).

# se  ... Sched Entity
# crq ... Cfs Run Queue
# rbl ... RunnaBLe
# rng ... RuNninG
# prd ... PeRioD
# ctb ... ConTriB

# It shows 2 se's of tasks running flat out, se1 starts to run at 0ms,
# se2 at 345ms. Depending on whether their runnable or running time is
# used to express the busy time the resulting signals of the crq's look
# different.

# f(x) = \sum usage_n*x^n = usage_0 + usage_1*x^1 + usage_2*x^2 + ... =
# usage*(1-a**x)/(1-a) (a != 1)

a = 0.978515625; # 4008/4096
load_avg_max = 47742;
load_avg_max_n = 345;
weight = 1024; # NICE_0_LOAD (don't take task priority into consideration)

# coefficient of the nth term usage_n*x^n (only 1024 and 1024/2 are used
# in this example)
usage(x) = 1024;

set xrange [0:2*load_avg_max_n];
set grid;
set key outside;

rbl_avg_sum_se1(x) = usage(x)*(1-a**x)/(1-a);
rbl_avg_sum_se2(x) = (x<=load_avg_max_n) ? 0 : (usage(x)*(1-a**(x-load_avg_max_n))/(1-a));

rbl_avg_prd(x) = load_avg_max;

rng_avg_sum_se1(x) = (x<=load_avg_max_n) ? (usage(x)*(1-a**x)/(1-a)) :
rng_avg_sum_se1(load_avg_max_n) - (usage(x)/2*(1-a**(x-load_avg_max_n))/(1-a));
rng_avg_sum_se2(x) = (x<=load_avg_max_n) ? 0 : (usage(x)/2*(1-a**(x-load_avg_max_n))/(1-a));


rbl_ctb_se1(x) = weight*rbl_avg_sum_se1(x)/(rbl_avg_prd(x) + 1);
rbl_ctb_se2(x) = weight*rbl_avg_sum_se2(x)/(rbl_avg_prd(x) + 1);
rbl_ctb_crq(x) = rbl_ctb_se1(x) + rbl_ctb_se2(x);

rng_ctb_se1(x) = weight*rng_avg_sum_se1(x)/(rbl_avg_prd(x) + 1);
rng_ctb_se2(x) = weight*rng_avg_sum_se2(x)/(rbl_avg_prd(x) + 1);
rng_ctb_crq(x) = rng_ctb_se1(x) + rng_ctb_se2(x);

set multiplot layout 2, 1 title "PELT"
set title "Runnable"
plot rbl_ctb_se1(x), rbl_ctb_se2(x), rbl_ctb_crq(x);
set title "Running"
plot rng_ctb_se1(x), rng_ctb_se2(x), rng_ctb_crq(x);
unset multiplot;
