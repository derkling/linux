==========================================
ARM CPUs capacity bindings
==========================================

==========================================
1 - Introduction
==========================================

ARM systems may be configured to have cpus with different power/performance
characteristics within the same chip. In this case, additional information
has to be made available to the kernel (the scheduler in particular) for
it to be aware of such differences and take decisions accordingly.

==========================================
2 - CPU capacity definition
==========================================

CPU capacity is a number that provides the scheduler information about CPUs
heterogeneity. Such heterogeneity can come from micro-architectural differences
(e.g., ARM big.LITTLE systems) or maximum frequency at which CPUs can run
(e.g., SMP systems with multiple frequency domains). Heterogeneity in this
context is about differing performance characteristics; this binding tries to
capture a first-order approximation of the relative performance of CPUs.

One simple way to estimate CPU capacities is to iteratively run a well-known
CPU user space benchmark (e.g, sysbench, dhrystone, etc.) on each CPU at
maximum frequency and then normalize values w.r.t.  the best performing CPU.
One can also do a statistically significant study of a wide collection of
benchmarks, but pros of such an approach are not really evident at the time of
writing.

==========================================
3 - capacity-scale
==========================================

CPUs capacities are defined with respect to capacity-scale property in the cpus
node [1]. The property is optional; if not defined a 1024 capacity-scale is
assumed. This property defines both the highest CPU capacity present in the
system and granularity of CPU capacity values.

==========================================
4 - capacity
==========================================

capacity is an optional cpu node [1] property: u32 value representing CPU
capacity, relative to capacity-scale. It is required and enforced that capacity
<= capacity-scale.

===========================================
5 - Examples
===========================================

Example 1 (ARM 64-bit, 6-cpu system, two clusters):
capacity-scale is not defined, so it is assumed to be 1024

cpus {
	#address-cells = <2>;
	#size-cells = <0>;

	cpu-map {
		cluster0 {
			core0 {
				cpu = <&A57_0>;
			};
			core1 {
				cpu = <&A57_1>;
			};
		};

		cluster1 {
			core0 {
				cpu = <&A53_0>;
			};
			core1 {
				cpu = <&A53_1>;
			};
			core2 {
				cpu = <&A53_2>;
			};
			core3 {
				cpu = <&A53_3>;
			};
		};
	};

	idle-states {
		entry-method = "arm,psci";

		CPU_SLEEP_0: cpu-sleep-0 {
			compatible = "arm,idle-state";
			arm,psci-suspend-param = <0x0010000>;
			local-timer-stop;
			entry-latency-us = <100>;
			exit-latency-us = <250>;
			min-residency-us = <150>;
		};

		CLUSTER_SLEEP_0: cluster-sleep-0 {
			compatible = "arm,idle-state";
			arm,psci-suspend-param = <0x1010000>;
			local-timer-stop;
			entry-latency-us = <800>;
			exit-latency-us = <700>;
			min-residency-us = <2500>;
		};
	};

	A57_0: cpu@0 {
		compatible = "arm,cortex-a57","arm,armv8";
		reg = <0x0 0x0>;
		device_type = "cpu";
		enable-method = "psci";
		next-level-cache = <&A57_L2>;
		clocks = <&scpi_dvfs 0>;
		cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;
		capacity = <1024>;
	};

	A57_1: cpu@1 {
		compatible = "arm,cortex-a57","arm,armv8";
		reg = <0x0 0x1>;
		device_type = "cpu";
		enable-method = "psci";
		next-level-cache = <&A57_L2>;
		clocks = <&scpi_dvfs 0>;
		cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;
		capacity = <1024>;
	};

	A53_0: cpu@100 {
		compatible = "arm,cortex-a53","arm,armv8";
		reg = <0x0 0x100>;
		device_type = "cpu";
		enable-method = "psci";
		next-level-cache = <&A53_L2>;
		clocks = <&scpi_dvfs 1>;
		cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;
		capacity = <447>;
	};

	A53_1: cpu@101 {
		compatible = "arm,cortex-a53","arm,armv8";
		reg = <0x0 0x101>;
		device_type = "cpu";
		enable-method = "psci";
		next-level-cache = <&A53_L2>;
		clocks = <&scpi_dvfs 1>;
		cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;
		capacity = <447>;
	};

	A53_2: cpu@102 {
		compatible = "arm,cortex-a53","arm,armv8";
		reg = <0x0 0x102>;
		device_type = "cpu";
		enable-method = "psci";
		next-level-cache = <&A53_L2>;
		clocks = <&scpi_dvfs 1>;
		cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;
		capacity = <447>;
	};

	A53_3: cpu@103 {
		compatible = "arm,cortex-a53","arm,armv8";
		reg = <0x0 0x103>;
		device_type = "cpu";
		enable-method = "psci";
		next-level-cache = <&A53_L2>;
		clocks = <&scpi_dvfs 1>;
		cpu-idle-states = <&CPU_SLEEP_0 &CLUSTER_SLEEP_0>;
		capacity = <447>;
	};

	A57_L2: l2-cache0 {
		compatible = "cache";
	};

	A53_L2: l2-cache1 {
		compatible = "cache";
	};
};

Example 2 (ARM 32-bit, 4-cpu system, two clusters,
	   cpus 0,1@1GHz, cpus 2,3@500MHz):
capacity-scale is equal to 2, so first cluster is twice faster than second
cluster (which matches with clock frequencies)

cpus {
	#address-cells = <1>;
	#size-cells = <0>;
	capacity-scale = <2>;

	cpu0: cpu@0 {
		device_type = "cpu";
		compatible = "arm,cortex-a15";
		reg = <0>;
		capacity = <2>;
	};

	cpu1: cpu@1 {
		device_type = "cpu";
		compatible = "arm,cortex-a15";
		reg = <1>;
		capacity = <2>;
	};

	cpu2: cpu@2 {
		device_type = "cpu";
		compatible = "arm,cortex-a15";
		reg = <0x100>;
		capacity = <1>;
	};

	cpu3: cpu@3 {
		device_type = "cpu";
		compatible = "arm,cortex-a15";
		reg = <0x101>;
		capacity = <1>;
	};
};

===========================================
6 - References
===========================================

[1] ARM Linux Kernel documentation - CPUs bindings
    Documentation/devicetree/bindings/arm/cpus.txt
