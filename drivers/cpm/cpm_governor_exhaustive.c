/**
 * This governor manages FSC generation through an exhaustive search process
 * that ideally builds and explores a complete DWRS COMBINATION TREE.
 *
 * DWRS COMBINATION TREE is composed by a dummy root and by a level for each
 * device that is registered to cpm_core. Each level includes a node for each
 * DWR of the corresponding device. Edges between nodes allows to build paths
 * that starts from tree dummy root and that are composed by a number of steps
 * equal to the number of registered device. Each step corresponds to a dwr of
 * a different device. Tree's edges allows all possible DWR combination.
 *
 * Governor is based on a recursive mechanism: each recursive call explores
 * DWRS of a different device. Each DWR is merged with the candidate FSC
 * generated by the merging of DWRS of the devices analized in less deeper
 * recursive level. If merge reach a successful conclusion and the current
 * analyzed device is not the last core registered device a new recursive call
 * is made, passing the new candidate fsc. Othewise the next device's DWR is
 * analyzed or the control return to the upper recursive level if no others
 * DWRs exists for current device.
 *
 * Stefano Bosisio <stebosisio@gmail.com>
 *
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/init.h>
#include <linux/list.h>
#include <linux/cpm.h>

/**
 * struct cpm_gov_asm_range - for ranges of candidate FSCs during search
 * @normal_range: candidate range for an asm
 * @node: next range of this candidate fsc
 * @old: previous candidate range for asm
 * @dev: refer to device from which range derives
 */
struct cpm_gov_asm_range {
	struct cpm_asm_range normal_range;
	struct list_head node;
	struct list_head old;
	struct cpm_dev *dev;
};

/* The number of cpm_dev */
static u8 dev_tot;

/* The head of cpm_gov_asm_list */
static LIST_HEAD(l_ranges);

/* total ranges of candidate FSC */
static int ranges_count;

/* The DWRs that maps with current candidate FSC */
static struct cpm_fsc_dwr *curr_dwr;

/* The internal list of founded FSCs */
static LIST_HEAD(found_fsc);

/* The number of FSCs found */
static u16 fsc_count;

/*********************************************************************
 *                     UNIFIED DEBUG HELPERS                         *
 *********************************************************************/

#ifdef CONFIG_CPM_GOVERNOR_DEBUG
#define dprintk(msg...) pr_info("cpm-gov-exh " msg)
#else
#define dprintk(msg...) do {} while (0);
#endif

#define iprintk(msg...) pr_info("cpm-gov-exh " msg)

#define eprintk(msg...) pr_err("cpm-gov-exh " msg)

/*********************************************************************
 *                   UTILITY FUNCTIONS PROTOTIPIES                   *
 *********************************************************************/

static int copy_dwr_to_gov_ranges(struct cpm_dev_dwr dwr, struct cpm_dev *dev);
static int merge_dwr_gov_ranges(struct cpm_dev_dwr dwr, struct cpm_dev *dev);
static int copy_found_fsc(void);
static int clean_gov_ranges(struct cpm_dev *owner_dev);


/**
 * build_fsc_list_recursive() - explorates DWRS combination tree
 * @l_dev: pointer to cpm_dev that is analyzed in the current recursive level
 * @ndev: number of device analyzed in the current recursive level
 */
int build_fsc_recurs(struct list_head *l_dev, u8 ndev)
{
	struct cpm_dev *dev = 0; /* device analized in this recursive level */
	u8 ndwr = 0; /* number of dwr for this level device */
	u8 idwr = 0; /* index for dwrs analysis */
	struct cpm_dev_dwr dwrs; /* dwr under analysis */
	int result = 0;

	/* get level's device infos*/
	dev = list_entry(l_dev->next, struct cpm_dev, node);
	ndwr = dev->dwrs_count;
	dprintk("recursive search dev: %2hu tot dwrs: %2hu\n", ndev, ndwr);

	/* iterate on dwrs of the current level device */
	for (idwr = 0; idwr < ndwr; idwr++) {
		dwrs = dev->dwrs[idwr];
		dprintk("analizyng dwr:%2hu of dev:%2hu\n", idwr, ndev);

		if (list_empty(&l_ranges)) {
			/* first device. DWR's ranges can be copied */
			dprintk("candidate ranges empty: adding DWR ranges\n");
			result = copy_dwr_to_gov_ranges(dwrs, dev);
		} else {
			/* some ranges exist. DWR's ranges must be merged */
			dprintk("candidate ranges NOT empty: merging dwr\n");
			result = merge_dwr_gov_ranges(dwrs, dev);
		}

		if ((result != -EINVAL) && (result != -ENOMEM)) {
			/* current DWR maps on current cadidate fsc */
			curr_dwr[ndev].dwr = &dev->dwrs[idwr];
			curr_dwr[ndev].cdev = dev;
			/* if is the last device a NEW FSC has been found */
			if (ndev == dev_tot - 1) {
				/* new fsc found */
				dprintk("new FSC found\n");
				result = copy_found_fsc();
			} else {
				 /* recursive call on the next device */
				result = build_fsc_recurs(l_dev->next, ndev+1);
			}
		}

		/* remove modification to gov ranges made by current device */
		clean_gov_ranges(dev);
		if (result == -ENOMEM)
			return -ENOMEM;
	}
	return 0;
}

/**
 * copy_dwr_to_gov_ranges - copies asms' ranges of a dwr to candidate's ranges
 * @dwr: dwr that is the ranges' source
 * @dev: device to which the dwr belong to
 */
static int copy_dwr_to_gov_ranges(struct cpm_dev_dwr dwr, struct cpm_dev *dev)
{
	u8 irgs = 0;
	struct cpm_gov_asm_range *new_rg;

	for (irgs = 0; irgs < dwr.asms_count; irgs++) {
		new_rg = kzalloc(sizeof(struct cpm_gov_asm_range), GFP_KERNEL);
		if (!new_rg) {
			eprintk("out-of-mem on cpm_gov_asm_range\n");
			return -ENOMEM;
		}
		new_rg->normal_range = dwr.asms[irgs];
		INIT_LIST_HEAD(&(new_rg->old));
		INIT_LIST_HEAD(&(new_rg->node));
		new_rg->dev = dev;
		dprintk("adding range t:%1hu l:%3hu u:%3hu\n",
			new_rg->normal_range.range.type,
			new_rg->normal_range.range.lower,
			new_rg->normal_range.range.upper);
		list_add(&(new_rg->node), &l_ranges);
		ranges_count++;
	}

	return 0;
}

/**
 * merge_dwr_gov_ranges - merges ranges of a dwr with current candidate ranges
 * @dwr: dwr that is the ranges' source
 * @dev: device to which the dwr belong to
 */
static int merge_dwr_gov_ranges(struct cpm_dev_dwr dwr, struct cpm_dev *dev)
{
	u8 irgs = 0;
	struct cpm_gov_asm_range *new_rg = 0;
	struct cpm_gov_asm_range *g_rg = 0;
	struct cpm_asm_range dev_rg;
	struct cpm_asm_range new_cand_rg;
	int merge_res = 0;

	for (irgs = 0; irgs < dwr.asms_count; irgs++) {
		dev_rg = dwr.asms[irgs];
		list_for_each_entry(g_rg, &l_ranges, node) {
			if (dev_rg.id == g_rg->normal_range.id)
				break;
		}
		if (dev_rg.id == g_rg->normal_range.id) {
			/* a range for this asm exists. It must be merged */
			dprintk("asm %2hu exists in gov ranges\n", dev_rg.id);
			new_cand_rg = g_rg->normal_range;

			merge_res = cpm_merge_range(&(new_cand_rg.range),
						&(dwr.asms[irgs].range));
			if (merge_res == -EINVAL) {
				/* no merge: stop current dwr analysis */
				dprintk("merge is not possible\n");
				return -EINVAL;
			}

			/* merging is possible: new candidate range*/
			dprintk("merge is possible\n");
			new_rg = kzalloc(sizeof(struct cpm_gov_asm_range),
					GFP_KERNEL);
			if (!new_rg)
				return -ENOMEM;
			new_rg->normal_range = new_cand_rg;
			INIT_LIST_HEAD(&(new_rg->node));
			INIT_LIST_HEAD(&(new_rg->old));
			new_rg->dev = dev;
			list_add_tail(&new_rg->old, &g_rg->old);
			list_replace(&g_rg->node, &new_rg->node);
			dprintk("adding range t:%1hu l:%3hu u:%3hu\n",
				new_rg->normal_range.range.type,
				new_rg->normal_range.range.lower,
				new_rg->normal_range.range.upper);
		} else {
			/* a range for this doesn't exist. It must be added */
			new_rg = 0;
			new_rg = kzalloc(sizeof(struct cpm_gov_asm_range),
					GFP_KERNEL);
			if (!new_rg)
				return -ENOMEM;
			new_rg->normal_range = dwr.asms[irgs];
			INIT_LIST_HEAD(&(new_rg->node));
			INIT_LIST_HEAD(&(new_rg->old));
			new_rg->dev = dev;
			list_add(&new_rg->node, &l_ranges);
			ranges_count++;
		}
	}
	return 0;
}

/**
 * copy_found_fsc - copy a candidate fsc to the list of found fsc
 */
static int copy_found_fsc(void)
{
	struct cpm_fsc *new_fsc = 0;
	u8 i = 0;
	struct cpm_gov_asm_range *g_rgs = 0;

	new_fsc = cpm_get_new_fsc();
	if (!new_fsc)
		return -ENOMEM;

	new_fsc->dwrs = kzalloc(sizeof(struct cpm_fsc_dwr) * dev_tot,
				GFP_KERNEL);
	if (!new_fsc->dwrs)
		goto clean_fsc;

	new_fsc->asms = kzalloc(sizeof(struct cpm_asm_range)*ranges_count,
				GFP_KERNEL);
	if (!new_fsc->asms)
		goto clean_dwrs;

	new_fsc->id = fsc_count++;
	new_fsc->gov_data = 0;
	new_fsc->pol_data = 0;
	INIT_LIST_HEAD(&(new_fsc->node));

	dprintk("copy range into FSC\n");
	list_for_each_entry(g_rgs, &l_ranges, node) {
		new_fsc->asms[i] = g_rgs->normal_range;
		i++;
	}
	new_fsc->asms_count = ranges_count;
	dprintk("%hu ranges copied into fsc\n", i);

	dprintk("copy dwr that bind to the new FSC\n");
	for (i = 0; i < dev_tot; i++)
		new_fsc->dwrs[i] = curr_dwr[i];
	new_fsc->dwrs_count = dev_tot;

	list_add_tail(&new_fsc->node, &found_fsc);
	dprintk("new fsc added to fsc list\n");

	return 0;

clean_dwrs:
	kfree(new_fsc->dwrs);
clean_fsc:
	kfree(new_fsc);
	return -ENOMEM;
}

/**
 * clean_gov_ranges - cleanup changes to candidate ranges made in a specific
 * recursive level
 * @owner_dev: device considered in the recursive level
 */
static int clean_gov_ranges(struct cpm_dev *owner_dev)
{
	struct cpm_gov_asm_range *grgs = 0;
	struct cpm_gov_asm_range *grgs_next = 0;
	struct cpm_gov_asm_range *grgs_sub = 0;

	list_for_each_entry_safe(grgs, grgs_next, &l_ranges, node) {
		if (grgs->dev == owner_dev) {
			if (list_empty(&grgs->old)) {
				list_del(&grgs->node);
				ranges_count--;
			} else {
				grgs_sub = container_of(grgs->old.next,
						struct cpm_gov_asm_range, old);
				list_replace(&(grgs->node), &(grgs_sub->node));
				list_del(&(grgs->old));
			}
			kfree(grgs);
		}
	}
	return 0;
}


/**
 * build_fsc_list_exhaustive() - function that builds FSCs' list
 * @dev_list: reference to the current list of device registered to the core
 * @dev_num: number of devices registered to cpm_core
 *
 * return value: 0 if dev_list is empty or if an empty FSCs list is
 *		generated, TRUE if fsc generation is successful
 */
int build_fsc_list_exhaustive(struct list_head *dev_list, u8 dev_num)
{
	int result;

	dprintk("entered in build_fsc_list\n");

	/* device list can't be empty */
	if (list_empty(dev_list)) {
		eprintk("error on build_fsc_list_exhaustive dev_list == 0\n");
		return -EINVAL;
	}

	/* number of devices can't be equal to 0 */
	if (!dev_num) {
		eprintk("error on build_fsc_list_exhaustive ndev == 0\n");
		return -EINVAL;
	}

	/* global data setup */
	dev_tot = dev_num;
	curr_dwr = kzalloc(sizeof(struct cpm_fsc_dwr) * dev_num, GFP_KERNEL);
	if (!curr_dwr) {
		eprintk("out-of-mem on cpm_fsc_dwr allocation\n");
		return -ENOMEM;
	}

	/* call to recursive function for DWRS COMBINATION TREE exploration */
	dprintk("starting recursive search\n");
	/* reset testing counters */

	result = build_fsc_recurs(dev_list, 0);

	if (result == -ENOMEM)
		goto out;

	if (list_empty(&found_fsc)) {
		dprintk("empty fsc list returned\n");
		result = -EINVAL;
	} else {
		dprintk("fsc list returned\n");
		result = 0;
		cpm_set_fsc_list(&found_fsc);
		INIT_LIST_HEAD(&found_fsc);
	}

out:
	/* global data reset */
	dev_tot = 0;
	ranges_count = 0;
	fsc_count = 0;
	kfree(curr_dwr);
	return result;
}

/* Governor data struct declaration */
struct cpm_governor cpm_governor_exhaustive = {
	.name = "exhaustive",
	.build_fsc_list = build_fsc_list_exhaustive,
};

/* Module initialization function */
static int __init cpm_governor_exhaustive_init(void)
{
	int err = FALSE;
	err = cpm_register_governor(&cpm_governor_exhaustive);
	return err;
}

/* Module unregistration function */
static void __exit cpm_governor_exhaustive_exit(void)
{
	return;
}

MODULE_AUTHOR("Stefano Bosisio <stebosisio@gmail.com>");
MODULE_DESCRIPTION("'cpm_governor_exhaustive' - cpm module that manage "
		"FSCs generation through exhaustive search");
MODULE_LICENSE("GPL");

module_init(cpm_governor_exhaustive_init);
module_exit(cpm_governor_exhaustive_exit);

